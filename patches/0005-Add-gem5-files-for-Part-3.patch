From dce6dd3e48086ebd24d4f601953e4b91deb8f12e Mon Sep 17 00:00:00 2001
From: Junmin Zhang <jzhang8@uccs.edu>
Date: Sun, 7 Dec 2025 15:20:16 -0700
Subject: [PATCH 5/8] Add gem5 files for Part 3

---
 gem5_files_part_3/ReplacementPolicies.py      | 183 ++++++++++++
 gem5_files_part_3/SConscript                  |  50 ++++
 .../mrclean_rp.cc                             |   2 +-
 .../mrclean_rp.hh                             |   0
 gem5_files_part_3/x86-gapbs-benchmarks.py     | 265 ++++++++++++++++++
 5 files changed, 499 insertions(+), 1 deletion(-)
 create mode 100644 gem5_files_part_3/ReplacementPolicies.py
 create mode 100644 gem5_files_part_3/SConscript
 rename mr_clean_rp.cc => gem5_files_part_3/mrclean_rp.cc (94%)
 rename mr_clean_rp.hh => gem5_files_part_3/mrclean_rp.hh (100%)
 create mode 100644 gem5_files_part_3/x86-gapbs-benchmarks.py

diff --git a/gem5_files_part_3/ReplacementPolicies.py b/gem5_files_part_3/ReplacementPolicies.py
new file mode 100644
index 0000000..bbe3fe1
--- /dev/null
+++ b/gem5_files_part_3/ReplacementPolicies.py
@@ -0,0 +1,183 @@
+# Copyright (c) 2018-2020 Inria
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are
+# met: redistributions of source code must retain the above copyright
+# notice, this list of conditions and the following disclaimer;
+# redistributions in binary form must reproduce the above copyright
+# notice, this list of conditions and the following disclaimer in the
+# documentation and/or other materials provided with the distribution;
+# neither the name of the copyright holders nor the names of its
+# contributors may be used to endorse or promote products derived from
+# this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+from m5.params import *
+from m5.proxy import *
+from m5.SimObject import SimObject
+
+
+class BaseReplacementPolicy(SimObject):
+    type = "BaseReplacementPolicy"
+    abstract = True
+    cxx_class = "gem5::replacement_policy::Base"
+    cxx_header = "mem/cache/replacement_policies/base.hh"
+
+
+class DuelingRP(BaseReplacementPolicy):
+    type = "DuelingRP"
+    cxx_class = "gem5::replacement_policy::Dueling"
+    cxx_header = "mem/cache/replacement_policies/dueling_rp.hh"
+
+    constituency_size = Param.Unsigned(
+        "The size of a region containing one sample"
+    )
+    team_size = Param.Unsigned(
+        "Number of entries in a sampling set that belong to a team"
+    )
+    replacement_policy_a = Param.BaseReplacementPolicy(
+        "Sub-replacement policy A"
+    )
+    replacement_policy_b = Param.BaseReplacementPolicy(
+        "Sub-replacement policy B"
+    )
+
+
+class FIFORP(BaseReplacementPolicy):
+    type = "FIFORP"
+    cxx_class = "gem5::replacement_policy::FIFO"
+    cxx_header = "mem/cache/replacement_policies/fifo_rp.hh"
+
+
+class SecondChanceRP(FIFORP):
+    type = "SecondChanceRP"
+    cxx_class = "gem5::replacement_policy::SecondChance"
+    cxx_header = "mem/cache/replacement_policies/second_chance_rp.hh"
+
+
+class LFURP(BaseReplacementPolicy):
+    type = "LFURP"
+    cxx_class = "gem5::replacement_policy::LFU"
+    cxx_header = "mem/cache/replacement_policies/lfu_rp.hh"
+
+
+class LRURP(BaseReplacementPolicy):
+    type = "LRURP"
+    cxx_class = "gem5::replacement_policy::LRU"
+    cxx_header = "mem/cache/replacement_policies/lru_rp.hh"
+
+
+class BIPRP(LRURP):
+    type = "BIPRP"
+    cxx_class = "gem5::replacement_policy::BIP"
+    cxx_header = "mem/cache/replacement_policies/bip_rp.hh"
+    btp = Param.Percent(3, "Percentage of blocks to be inserted as MRU")
+
+
+class LIPRP(BIPRP):
+    btp = 0
+
+
+class MRURP(BaseReplacementPolicy):
+    type = "MRURP"
+    cxx_class = "gem5::replacement_policy::MRU"
+    cxx_header = "mem/cache/replacement_policies/mru_rp.hh"
+
+
+class RandomRP(BaseReplacementPolicy):
+    type = "RandomRP"
+    cxx_class = "gem5::replacement_policy::Random"
+    cxx_header = "mem/cache/replacement_policies/random_rp.hh"
+
+
+class BRRIPRP(BaseReplacementPolicy):
+    type = "BRRIPRP"
+    cxx_class = "gem5::replacement_policy::BRRIP"
+    cxx_header = "mem/cache/replacement_policies/brrip_rp.hh"
+    num_bits = Param.Int(2, "Number of bits per RRPV")
+    hit_priority = Param.Bool(
+        False, "Prioritize evicting blocks that havent had a hit recently"
+    )
+    btp = Param.Percent(
+        3, "Percentage of blocks to be inserted with long RRPV"
+    )
+
+
+class RRIPRP(BRRIPRP):
+    btp = 100
+
+
+class DRRIPRP(DuelingRP):
+    # The constituency_size and the team_size must be manually provided, where:
+    #     constituency_size = num_cache_entries /
+    #         (num_dueling_sets * num_entries_per_set)
+    # The paper assumes that:
+    #     num_dueling_sets = 32
+    #     team_size = num_entries_per_set
+    replacement_policy_a = BRRIPRP()
+    replacement_policy_b = RRIPRP()
+
+
+class NRURP(BRRIPRP):
+    btp = 100
+    num_bits = 1
+
+
+class SHiPRP(BRRIPRP):
+    type = "SHiPRP"
+    abstract = True
+    cxx_class = "gem5::replacement_policy::SHiP"
+    cxx_header = "mem/cache/replacement_policies/ship_rp.hh"
+
+    shct_size = Param.Unsigned(16384, "Number of SHCT entries")
+    # By default any value greater than 0 is enough to change insertion policy
+    insertion_threshold = Param.Percent(
+        1, "Percentage at which an entry changes insertion policy"
+    )
+    # Always make hits mark entries as last to be evicted
+    hit_priority = True
+    # Let the predictor decide when to change insertion policy
+    btp = 0
+
+
+class SHiPMemRP(SHiPRP):
+    type = "SHiPMemRP"
+    cxx_class = "gem5::replacement_policy::SHiPMem"
+    cxx_header = "mem/cache/replacement_policies/ship_rp.hh"
+
+
+class SHiPPCRP(SHiPRP):
+    type = "SHiPPCRP"
+    cxx_class = "gem5::replacement_policy::SHiPPC"
+    cxx_header = "mem/cache/replacement_policies/ship_rp.hh"
+
+
+class TreePLRURP(BaseReplacementPolicy):
+    type = "TreePLRURP"
+    cxx_class = "gem5::replacement_policy::TreePLRU"
+    cxx_header = "mem/cache/replacement_policies/tree_plru_rp.hh"
+    num_leaves = Param.Int(Parent.assoc, "Number of leaves in each tree")
+
+
+class WeightedLRURP(LRURP):
+    type = "WeightedLRURP"
+    cxx_class = "gem5::replacement_policy::WeightedLRU"
+    cxx_header = "mem/cache/replacement_policies/weighted_lru_rp.hh"
+
+
+class MrCleanRP(BaseReplacementPolicy):
+    type = "MrCleanRP"
+    cxx_class = "gem5::replacement_policy::MrClean"
+    cxx_header = "mem/cache/replacement_policies/mrclean_rp.hh"
diff --git a/gem5_files_part_3/SConscript b/gem5_files_part_3/SConscript
new file mode 100644
index 0000000..b774279
--- /dev/null
+++ b/gem5_files_part_3/SConscript
@@ -0,0 +1,50 @@
+# -*- mode:python -*-
+
+# Copyright (c) 2018 Inria
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are
+# met: redistributions of source code must retain the above copyright
+# notice, this list of conditions and the following disclaimer;
+# redistributions in binary form must reproduce the above copyright
+# notice, this list of conditions and the following disclaimer in the
+# documentation and/or other materials provided with the distribution;
+# neither the name of the copyright holders nor the names of its
+# contributors may be used to endorse or promote products derived from
+# this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+Import('*')
+
+SimObject('ReplacementPolicies.py', sim_objects=[
+    'BaseReplacementPolicy', 'DuelingRP', 'FIFORP', 'SecondChanceRP',
+    'LFURP', 'LRURP', 'BIPRP', 'MRURP', 'RandomRP', 'BRRIPRP', 'SHiPRP',
+    'SHiPMemRP', 'SHiPPCRP', 'TreePLRURP', 'WeightedLRURP', 'MrCleanRP'])
+
+Source('bip_rp.cc')
+Source('brrip_rp.cc')
+Source('dueling_rp.cc')
+Source('fifo_rp.cc')
+Source('lfu_rp.cc')
+Source('lru_rp.cc')
+Source('mrclean_rp.cc')
+Source('mru_rp.cc')
+Source('random_rp.cc')
+Source('second_chance_rp.cc')
+Source('ship_rp.cc')
+Source('tree_plru_rp.cc')
+Source('weighted_lru_rp.cc')
+
+GTest('replaceable_entry.test', 'replaceable_entry.test.cc')
diff --git a/mr_clean_rp.cc b/gem5_files_part_3/mrclean_rp.cc
similarity index 94%
rename from mr_clean_rp.cc
rename to gem5_files_part_3/mrclean_rp.cc
index bb9cb2f..357e8ab 100644
--- a/mr_clean_rp.cc
+++ b/gem5_files_part_3/mrclean_rp.cc
@@ -1,4 +1,4 @@
-#include "mem/cache/replacement_policies/mr_clean_rp.hh"
+#include "mem/cache/replacement_policies/mrclean_rp.hh"
 
 #include <cassert>
 #include <memory>
diff --git a/mr_clean_rp.hh b/gem5_files_part_3/mrclean_rp.hh
similarity index 100%
rename from mr_clean_rp.hh
rename to gem5_files_part_3/mrclean_rp.hh
diff --git a/gem5_files_part_3/x86-gapbs-benchmarks.py b/gem5_files_part_3/x86-gapbs-benchmarks.py
new file mode 100644
index 0000000..61c2bd5
--- /dev/null
+++ b/gem5_files_part_3/x86-gapbs-benchmarks.py
@@ -0,0 +1,265 @@
+# Copyright (c) 2021 The Regents of the University of California.
+# All rights reserved.
+#
+# Redistribution and use in source and binary forms, with or without
+# modification, are permitted provided that the following conditions are
+# met: redistributions of source code must retain the above copyright
+# notice, this list of conditions and the following disclaimer;
+# redistributions in binary form must reproduce the above copyright
+# notice, this list of conditions and the following disclaimer in the
+# documentation and/or other materials provided with the distribution;
+# neither the name of the copyright holders nor the names of its
+# contributors may be used to endorse or promote products derived from
+# this software without specific prior written permission.
+#
+# THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
+# "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
+# LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
+# A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
+# OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
+# SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
+# LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
+# OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+"""
+Script to run GAPBS benchmarks with gem5. The script expects the
+benchmark program and the simulation size to run. The input is in the format
+<benchmark_prog> <size> <synthetic>
+The system is fixed with 2 CPU cores, MESI Two Level system cache and 3 GiB
+DDR4 memory. It uses the x86 board.
+
+This script will count the total number of instructions executed
+in the ROI. It also tracks how much wallclock and simulated time.
+
+Usage:
+------
+
+```
+scons build/X86/gem5.opt
+./build/X86/gem5.opt \
+    configs/example/gem5_library/x86-gabps-benchmarks.py \
+    --benchmark <benchmark_name> \
+    --synthetic <synthetic> \
+    --size <simulation_size/graph_name>
+```
+"""
+
+import argparse
+import sys
+import time
+
+import m5
+from m5.objects import Root, ReplacementPolicies
+# from m5.objects.ReplacementPolicies import LIPRP
+from m5.objects.ReplacementPolicies import RandomRP, LRURP, TreePLRURP, LIPRP, MRURP, FIFORP, SecondChanceRP, MrCleanRP
+
+from gem5.coherence_protocol import CoherenceProtocol
+from gem5.components.boards.x86_board import X86Board
+from gem5.components.memory import DualChannelDDR4_2400
+from gem5.components.processors.cpu_types import CPUTypes
+from gem5.components.processors.simple_switchable_processor import (
+    SimpleSwitchableProcessor,
+)
+from gem5.isas import ISA
+from gem5.resources.resource import obtain_resource
+from gem5.simulate.exit_event import ExitEvent
+from gem5.simulate.simulator import Simulator
+from gem5.utils.requires import requires
+
+requires(
+    isa_required=ISA.X86,
+    coherence_protocol_required=CoherenceProtocol.MESI_TWO_LEVEL,
+    kvm_required=True,  # Comment out on 11/30/2025
+)
+
+parser = argparse.ArgumentParser(
+    description="An example configuration script to run the gapbs benchmarks."
+)
+
+gapbs_suite = obtain_resource(
+    "gapbs-benchmark-suite", resource_version="1.0.0"
+)
+
+# The only positional argument accepted is the benchmark name in this script.
+
+parser.add_argument(
+    "--benchmark",
+    type=str,
+    required=True,
+    help="Input the benchmark program to execute.",
+    choices=[workload.get_id() for workload in gapbs_suite],
+)
+
+# Added on 11/30/2025
+rp_class_map = {
+    "Random": RandomRP,
+    "LRU": LRURP,
+    "TreePLRU": TreePLRURP,
+    "LIP": LIPRP,
+    "MRU": MRURP,
+    "FIFO": FIFORP,
+    "SecondChance": SecondChanceRP,
+    "MrClean": MrCleanRP,
+}
+
+parser.add_argument(
+    "--l1i-rp",
+    type=str,
+    default="TreePLRU",
+    choices=list(rp_class_map.keys()),
+    help="Replacement policy for L1 instruction cache",
+)
+
+parser.add_argument(
+    "--l1d-rp",
+    type=str,
+    default="TreePLRU",
+    choices=list(rp_class_map.keys()),
+    help="Replacement policy for L1 data cache",
+)
+
+# Added on 12/3/2025
+parser.add_argument(
+    "--l2-rp",
+    type=str,
+    default="TreePLRU",
+    choices=list(rp_class_map.keys()),
+    help="Replacement policy for L2 cache",
+)
+
+args = parser.parse_args()
+
+# Restriction for L1 Instruction Cache - Added on 12/4/2025
+if args.l1i_rp == "MrClean":
+    raise ValueError("MrClean replacement policy is not allowed for the L1 instruction cache.")
+
+# Instantiate SimObjects
+l1i_rp_obj = rp_class_map[args.l1i_rp]()
+l1d_rp_obj = rp_class_map[args.l1d_rp]()
+l2_rp_obj = rp_class_map[args.l2_rp]()
+# Setting up all the fixed system parameters here
+# Caches: MESI Two Level Cache Hierarchy
+
+from gem5.components.cachehierarchies.ruby.mesi_two_level_cache_hierarchy import (
+    MESITwoLevelCacheHierarchy,
+)
+
+cache_hierarchy = MESITwoLevelCacheHierarchy(
+    l1d_size="32KiB",
+    l1d_assoc=8,
+    l1i_size="32KiB",
+    l1i_assoc=8,
+    l2_size="256KiB",
+    l2_assoc=16,
+    # l1d_rp=LIPRP(), # Comment out on 11/30/2025
+    # l1i_rp=LIPRP(), # Comment out on 11/30/2025
+    l1d_rp=l1d_rp_obj, # Changed on 11/30/2025
+    l1i_rp=l1i_rp_obj, # Changed on 11/30/2025
+    num_l2_banks=2,
+    l2_rp=l2_rp_obj,
+)
+# Memory: Dual Channel DDR4 2400 DRAM device.
+# The X86 board only supports 3 GiB of main memory.
+
+memory = DualChannelDDR4_2400(size="3GiB")
+
+# Here we setup the processor. This is a special switchable processor in which
+# a starting core type and a switch core type must be specified. Once a
+# configuration is instantiated a user may call `processor.switch()` to switch
+# from the starting core types to the switch core types. In this simulation
+# we start with KVM cores to simulate the OS boot, then switch to the Timing
+# cores for the command we wish to run after boot.
+
+processor = SimpleSwitchableProcessor(
+    starting_core_type=CPUTypes.KVM,
+    # starting_core_type=CPUTypes.O3, # Changed to O3 from KVM on 11/30/2025 
+    switch_core_type=CPUTypes.TIMING,
+    isa=ISA.X86,
+    num_cores=2,
+)
+
+# Here we setup the board. The X86Board allows for Full-System X86 simulations
+
+board = X86Board(
+    clk_freq="3GHz",
+    processor=processor,
+    memory=memory,
+    cache_hierarchy=cache_hierarchy,
+)
+
+# Here we set the FS workload, i.e., gapbs benchmark program
+# After simulation has ended you may inspect
+# `m5out/system.pc.com_1.device` to the stdout, if any.
+
+# After the system boots, we execute the benchmark program and wait till the
+# ROI `workbegin` annotation is reached. We start collecting the number of
+# committed instructions till ROI ends (marked by `workend`). We then finish
+# executing the rest of the benchmark.
+
+board.set_workload(obtain_resource(args.benchmark))
+
+
+def handle_workbegin():
+    print("Done booting Linux")
+    print("Resetting stats at the start of ROI!")
+    m5.stats.reset()
+    global start_tick
+    start_tick = m5.curTick()
+    processor.switch()
+    yield False  # E.g., continue the simulation.
+
+
+def handle_workend():
+    print("Dump stats at the end of the ROI!")
+    m5.stats.dump()
+    yield True  # Stop the simulation. We're done.
+
+
+simulator = Simulator(
+    board=board,
+    on_exit_event={
+        ExitEvent.WORKBEGIN: handle_workbegin(),
+        ExitEvent.WORKEND: handle_workend(),
+    },
+)
+
+# We maintain the wall clock time.
+
+globalStart = time.time()
+
+print("Running the simulation")
+print("Using KVM cpu")
+
+# There are a few thihngs to note regarding the gapbs benchamrks. The first is
+# that there are several ROI annotations in the code present in the disk image.
+# These ROI begin and end calls are inside a loop. Therefore, we only simulate
+# the first ROI annotation in details. The X86Board currently does not support
+#  `work items started count reached`.
+
+simulator.run()
+end_tick = m5.curTick()
+# Since we simulated the ROI in details, therefore, simulation is over at this
+# point.
+
+# Simulation is over at this point. We acknowledge that all the simulation
+# events were successful.
+print("All simulation events were successful.")
+
+# We print the final simulation statistics.
+print("Done with the simulation")
+print()
+print("Performance statistics:")
+
+print(
+    f"Simulated time in ROI: {(end_tick - start_tick) / 1000000000000.0:.2f}s"
+)
+print(
+    "Ran a total of", simulator.get_current_tick() / 1e12, "simulated seconds"
+)
+print(
+    "Total wallclock time: %.2fs, %.2f min"
+    % (time.time() - globalStart, (time.time() - globalStart) / 60)
+)
-- 
2.43.0

